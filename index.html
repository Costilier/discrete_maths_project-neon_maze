<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pathfinding & Graph Algorithms Visualizer</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg: #f4f5f8;
    --card: #ffffff;
    --muted: #6b7280;
    --text: #0f1724;
    --accent: #5b2e86;          /* royal purple */
    --accent-soft: #7a4ab1;
    --border: #e6e8eb;
    --panel-shadow: 0 8px 20px rgba(15, 23, 36, 0.06);
    --canvas-bg: #0b0b0f;
    --path: #ffd86b;
    --success: #2d8f6f;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #fbfbfd 0%, var(--bg) 100%);
    color:var(--text);
    display:flex;
    justify-content:center;
    padding:28px;
  }

  .container{
    width:100%;
    max-width:1200px;
    display:grid;
    grid-template-columns: 330px 1fr 280px;
    gap:20px;
    align-items:start;
  }

  header{
    grid-column:1/-1;
    display:flex;
    flex-direction:column;
    gap:6px;
    margin-bottom:6px;
  }
  header h1{
    margin:0;
    font-size:1.4rem;
    font-weight:700;
    color:var(--accent);
  }
  header p{
    margin:0;
    color:var(--muted);
    font-size:0.95rem;
  }

  /* Left control card */
  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:12px;
    padding:18px;
    box-shadow: var(--panel-shadow);
  }

  label{ display:block; font-size:0.85rem; color:var(--muted); margin-bottom:8px; }
  input[type=number], select{
    width:100%;
    padding:10px 12px;
    border-radius:8px;
    border:1px solid var(--border);
    background:#fff;
    font-family:'JetBrains Mono', monospace;
    font-size:0.95rem;
    color:var(--text);
  }
  .control-row{ display:flex; gap:10px; margin-top:12px; }
  .btn{
    padding:10px 12px;
    border-radius:10px;
    border:none;
    cursor:pointer;
    font-weight:600;
    font-size:0.95rem;
  }
  .btn-primary{ background:var(--accent); color:white; box-shadow:0 6px 18px rgba(91,46,134,0.12); }
  .btn-ghost{ background:transparent; border:1px solid var(--border); color:var(--accent); }

  .small-note{ margin-top:12px; font-size:0.86rem; color:var(--muted) }

  /* Middle: canvas area */
  .stage{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:12px;
    padding:18px;
    box-shadow:var(--panel-shadow);
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
  }
  .canvas-wrap{
    background:linear-gradient(180deg,#0c0d12 0%, #0a0a0d 100%);
    border-radius:10px;
    padding:14px;
    box-shadow: inset 0 6px 18px rgba(0,0,0,0.55);
  }
  canvas{
    display:block;
    width:720px;
    height:720px;
    border-radius:6px;
    background:var(--canvas-bg);
    image-rendering:pixelated;
  }
  .stage .meta{
    width:100%;
    display:flex;
    justify-content:space-between;
    align-items:center;
    color:var(--muted);
    font-size:0.95rem;
  }

  /* Right: stats */
  .stats{ display:flex; flex-direction:column; gap:12px; }
  .stat-item{ background:var(--card); border:1px solid var(--border); padding:14px; border-radius:10px; box-shadow:var(--panel-shadow) }
  .stat-item h4{ margin:0 0 6px 0; color:var(--accent); font-size:0.95rem }
  .stat-item p{ margin:0; font-weight:700; font-family:'JetBrains Mono', monospace; color:var(--text) }

  /* responsive */
  @media (max-width:1120px){
    .container{ grid-template-columns: 1fr; }
    canvas{ width:640px; height:640px; }
  }
  @media (max-width:720px){
    canvas{ width:320px; height:320px; }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Pathfinding & Graph Algorithms Visualizer</h1>
      <p>Application of Discrete Mathematics & Graph Theory in Game Development — interactive demonstration of maze generation and route-finding algorithms.</p>
    </header>

    <!-- CONTROLS -->
    <aside class="card" aria-labelledby="controls-title">
      <h3 id="controls-title" style="margin:0 0 12px 0; color:var(--accent); font-size:1rem">Controls</h3>

      <label for="cols">Columns (2–150)</label>
      <input id="cols" type="number" min="2" max="150" value="24" />

      <label for="rows" style="margin-top:10px">Rows (2–150)</label>
      <input id="rows" type="number" min="2" max="150" value="24" />

      <label for="gen" style="margin-top:10px">Generator</label>
      <select id="gen">
        <option value="backtrack">Recursive Backtracker (DFS)</option>
        <option value="prim">Frontier (Prim-like)</option>
        <option value="kruskal">Union-Shuffle (Kruskal-like)</option>
      </select>

      <label for="solve" style="margin-top:10px">Solver</label>
      <select id="solve">
        <option value="bfs">BFS (shortest)</option>
        <option value="dfs">DFS (path)</option>
      </select>

      <div class="control-row" style="margin-top:14px">
        <button id="buildBtn" class="btn btn-primary">Build</button>
        <button id="solveBtn" class="btn btn-primary" style="background:var(--accent-soft)">Solve</button>
      </div>

      <div class="control-row" style="margin-top:10px">
        <button id="resetBtn" class="btn btn-ghost">Reset</button>
        <button id="saveBtn" class="btn btn-ghost">Export PNG</button>
      </div>

      <div class="small-note">Tip: Increase grid size carefully — very large grids may slow animations on some machines.</div>
    </aside>

    <!-- CANVAS AREA -->
    <main class="stage" role="main" aria-labelledby="visual-title">
      <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
        <div id="visual-title" style="font-weight:600; color:var(--accent)">Visualizer</div>
        <div style="color:var(--muted); font-size:0.95rem">Start: top-left · Goal: bottom-right</div>
      </div>

      <div class="canvas-wrap" aria-hidden="false">
        <canvas id="vizCanvas" width="720" height="720" role="img" aria-label="Maze canvas"></canvas>
      </div>

      <div class="meta">
        <div id="statusText">Status: <span style="font-weight:700; color:var(--muted)">ready</span></div>
        <div id="gridText" style="font-family:'JetBrains Mono', monospace; color:var(--muted)">Grid: 24 × 24</div>
      </div>
    </main>

    <!-- STATS -->
    <aside class="stats">
      <div class="stat-item">
        <h4>Last Generator</h4>
        <p id="statGen">—</p>
      </div>
      <div class="stat-item">
        <h4>Last Solver</h4>
        <p id="statSolve">—</p>
      </div>
      <div class="stat-item">
        <h4>Visited Steps</h4>
        <p id="statSteps">0</p>
      </div>
      <div class="stat-item">
        <h4>Path Length</h4>
        <p id="statLength">0</p>
      </div>
      <div class="stat-item">
        <h4>Paths Found</h4>
        <p id="statPaths">0</p>
      </div>
    </aside>
  </div>

<script>
/* ---------------------- Implementation (rewritten, original names) ---------------------- */

const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

/* controls */
const colsEl = document.getElementById('cols');
const rowsEl = document.getElementById('rows');
const genEl = document.getElementById('gen');
const solveEl = document.getElementById('solve');
const buildBtn = document.getElementById('buildBtn');
const solveBtn = document.getElementById('solveBtn');
const resetBtn = document.getElementById('resetBtn');
const saveBtn = document.getElementById('saveBtn');

const statusText = document.getElementById('statusText').querySelector('span');
const gridText = document.getElementById('gridText');
const statGen = document.getElementById('statGen');
const statSolve = document.getElementById('statSolve');
const statSteps = document.getElementById('statSteps');
const statLength = document.getElementById('statLength');
const statPaths = document.getElementById('statPaths');

let COLS = 24, ROWS = 24, CELL = 24;
let grid = []; // grid[r][c] = {walls:[top,right,bottom,left], marked:false}
let start = {c:0,r:0}, goal = {c:0,r:0};
let busy = false;
const FRAME_MS = 45; // animation pace

/* helpers */
const pause = ms => new Promise(res => setTimeout(res, ms));
const valid = (c,r) => c>=0 && r>=0 && c<COLS && r<ROWS;
const idx = (c,r) => r*COLS + c;

function initEmpty(c,w){
  COLS = Math.max(2, Math.min(150, c));
  ROWS = Math.max(2, Math.min(150, w));
  CELL = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
  grid = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>({ walls:[true,true,true,true], marked:false })));
  start = {c:0,r:0};
  goal = {c:COLS-1,r:ROWS-1};
  gridText.textContent = `Grid: ${COLS} × ${ROWS}`;
}

/* drawing */
function clearCanvas(){
  ctx.fillStyle = '#0b0b0f';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
function strokeLine(x1,y1,x2,y2, width=2, color='#ddd'){
  ctx.lineWidth = width; ctx.strokeStyle = color;
  ctx.beginPath(); ctx.moveTo(x1+0.5,y1+0.5); ctx.lineTo(x2+0.5,y2+0.5); ctx.stroke();
}
function render(path=null, highlight=null){
  clearCanvas();
  ctx.strokeStyle = '#2b2b2f';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = grid[r][c];
      const X = c*CELL, Y = r*CELL;
      if(cell.walls[0]) strokeLine(X,Y, X+CELL, Y);
      if(cell.walls[1]) strokeLine(X+CELL,Y, X+CELL, Y+CELL);
      if(cell.walls[2]) strokeLine(X,Y+CELL, X+CELL, Y+CELL);
      if(cell.walls[3]) strokeLine(X,Y, X, Y+CELL);
    }
  }

  // start & goal
  ctx.fillStyle = '#7fb77f';
  ctx.fillRect(start.c*CELL+4, start.r*CELL+4, CELL-8, CELL-8);
  ctx.fillStyle = '#c27a4b';
  ctx.fillRect(goal.c*CELL+4, goal.r*CELL+4, CELL-8, CELL-8);

  // path
  if(path && path.length){
    ctx.strokeStyle = 'rgba(255,216,107,0.95)';
    ctx.lineWidth = Math.max(2, Math.floor(CELL/6));
    ctx.beginPath();
    for(let i=0;i<path.length-1;i++){
      const a = path[i], b = path[i+1];
      ctx.moveTo(a.c*CELL + CELL/2, a.r*CELL + CELL/2);
      ctx.lineTo(b.c*CELL + CELL/2, b.r*CELL + CELL/2);
    }
    ctx.stroke();
  }

  // highlight
  if(highlight){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(highlight.c*CELL+2, highlight.r*CELL+2, CELL-4, CELL-4);
  }
}

/* remove wall */
function breakWall(c1,r1,c2,r2){
  if(c1===c2 && r1===r2) return;
  if(c1===c2){
    if(r1===r2+1){ grid[r1][c1].walls[0]=false; grid[r2][c2].walls[2]=false; }
    else if(r1+1===r2){ grid[r1][c1].walls[2]=false; grid[r2][c2].walls[0]=false; }
  } else if(r1===r2){
    if(c1===c2+1){ grid[r1][c1].walls[3]=false; grid[r2][c2].walls[1]=false; }
    else if(c1+1===c2){ grid[r1][c1].walls[1]=false; grid[r2][c2].walls[3]=false; }
  }
}

/* ---------------- GENERATORS ---------------- */

/* 1: Recursive Backtracker (stack-based) */
async function genBacktracker(){
  const stack = [{c:0,r:0}];
  grid[0][0].marked = true;
  while(stack.length){
    const cur = stack.pop();
    const {c,r} = cur;
    const neighbours = [];
    if(r>0 && !grid[r-1][c].marked) neighbours.push({c, r:r-1});
    if(c<COLS-1 && !grid[r][c+1].marked) neighbours.push({c:c+1, r});
    if(r<ROWS-1 && !grid[r+1][c].marked) neighbours.push({c, r:r+1});
    if(c>0 && !grid[r][c-1].marked) neighbours.push({c:c-1, r});

    if(neighbours.length){
      const nxt = neighbours[Math.floor(Math.random()*neighbours.length)];
      breakWall(c,r,nxt.c,nxt.r);
      grid[nxt.r][nxt.c].marked = true;
      stack.push(cur, nxt);
    }

    render(null, {c,r});
    await pause(18);
  }
  // reset marks
  for(let rr=0; rr<ROWS; rr++) for(let cc=0; cc<COLS; cc++) grid[rr][cc].marked=false;
}

/* 2: Frontier (Prim-like) */
async function genFrontier(){
  const included = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
  const frontier = [];
  const sx = Math.floor(Math.random()*COLS), sy = Math.floor(Math.random()*ROWS);
  included[sy][sx]=true;

  const pushEdge = (c,r, nc,nr) => { if(valid(nc,nr)) frontier.push({c,r,nc,nr}); };
  if(sy>0) pushEdge(sx,sy,sx,sy-1);
  if(sx<COLS-1) pushEdge(sx,sy,sx+1,sy);
  if(sy<ROWS-1) pushEdge(sx,sy,sx,sy+1);
  if(sx>0) pushEdge(sx,sy,sx-1,sy);

  while(frontier.length){
    const i = Math.floor(Math.random()*frontier.length);
    const e = frontier.splice(i,1)[0];
    if(included[e.nr][e.nc]) continue;
    breakWall(e.c,e.r,e.nc,e.nr);
    included[e.nr][e.nc] = true;
    // add neighbors
    const c=e.nc, r=e.nr;
    if(r>0 && !included[r-1][c]) frontier.push({c,r,nc:c,nr:r-1});
    if(c<COLS-1 && !included[r][c+1]) frontier.push({c,r,nc:c+1,nr:r});
    if(r<ROWS-1 && !included[r+1][c]) frontier.push({c,r,nc:c,nr:r+1});
    if(c>0 && !included[r][c-1]) frontier.push({c,r,nc:c-1,nr:r});
    render();
    await pause(12);
  }
}

/* 3: Union-Find shuffled (Kruskal-like) */
async function genUnionShuffle(){
  const edges = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(c < COLS-1) edges.push({a:idx(c,r), b:idx(c+1,r), ac:c, ar:r, bc:c+1, br:r});
      if(r < ROWS-1) edges.push({a:idx(c,r), b:idx(c,r+1), ac:c, ar:r, bc:c, br:r+1});
    }
  }
  shuffle(edges);
  const parent = Array(COLS*ROWS).fill(0).map((_,i)=>i);
  const findP = x => parent[x]===x ? x : (parent[x]=findP(parent[x]));
  const unite = (a,b) => parent[findP(a)] = findP(b);

  for(const e of edges){
    if(findP(e.a) !== findP(e.b)){
      breakWall(e.ac,e.ar,e.bc,e.br);
      unite(e.a, e.b);
      render();
      await pause(10);
    }
  }
}

/* ---------------- SOLVERS ---------------- */

function reconstruct(prev, tc, tr){
  const path = [];
  let key = `${tc},${tr}`;
  path.push({c:tc,r:tr});
  while(prev.has(key)){
    const p = prev.get(key);
    path.push({c:p.c,r:p.r});
    key = `${p.c},${p.r}`;
  }
  return path.reverse();
}

function solverBFS(){
  const q = [{c:start.c, r:start.r}];
  const seen = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
  const prev = new Map();
  seen[start.r][start.c] = true;
  let visitedCount = 0;

  while(q.length){
    const cur = q.shift(); visitedCount++;
    if(cur.c===goal.c && cur.r===goal.r){
      statSteps.textContent = String(visitedCount);
      return reconstruct(prev, goal.c, goal.r);
    }
    const cell = grid[cur.r][cur.c];
    const dirs = [
      {dc:0,dr:-1,open:!cell.walls[0]},
      {dc:1,dr:0,open:!cell.walls[1]},
      {dc:0,dr:1,open:!cell.walls[2]},
      {dc:-1,dr:0,open:!cell.walls[3]}
    ];
    for(const d of dirs){
      const nc = cur.c + d.dc, nr = cur.r + d.dr;
      if(d.open && valid(nc,nr) && !seen[nr][nc]){
        seen[nr][nc] = true;
        prev.set(`${nc},${nr}`, {c:cur.c, r:cur.r});
        q.push({c:nc, r:nr});
      }
    }
  }
  statSteps.textContent = String(visitedCount);
  return null;
}

function solverDFS(){
  const seen = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
  const prev = new Map();
  let found = false;

  function walk(c,r){
    if(found) return;
    seen[r][c] = true;
    if(c===goal.c && r===goal.r){ found=true; return; }
    const cell = grid[r][c];
    const dirs = [
      {dc:0,dr:-1,open:!cell.walls[0]},
      {dc:1,dr:0,open:!cell.walls[1]},
      {dc:0,dr:1,open:!cell.walls[2]},
      {dc:-1,dr:0,open:!cell.walls[3]}
    ];
    for(const d of dirs){
      const nc=c+d.dc, nr=r+d.dr;
      if(d.open && valid(nc,nr) && !seen[nr][nc]){
        prev.set(`${nc},${nr}`, {c,r});
        walk(nc,nr);
        if(found) return;
      }
    }
  }
  walk(start.c,start.r);
  return found ? reconstruct(prev, goal.c, goal.r) : null;
}

/* progressive reveal */
async function reveal(path){
  if(!path || !path.length) return;
  statLength.textContent = String(path.length);
  statPaths.textContent = '1';
  for(let i=0;i<path.length-1;i++){
    const partial = path.slice(0, i+2);
    render(partial, path[i+1]);
    await pause(FRAME_MS);
  }
}

/* ---------------- DRIVERS ---------------- */

async function doBuild(){
  if(busy) return;
  busy = true;
  statusText.textContent = 'building';
  statGen.textContent = genEl.value;
  initEmpty(parseInt(colsEl.value,10)||24, parseInt(rowsEl.value,10)||24);

  if(genEl.value==='backtrack') await genBacktracker();
  else if(genEl.value==='prim') await genFrontier();
  else if(genEl.value==='kruskal') await genUnionShuffle();

  render();
  statusText.textContent = 'built';
  statSteps.textContent = '0';
  statLength.textContent = '0';
  statPaths.textContent = '0';
  busy = false;
}

async function doSolve(){
  if(busy) return;
  busy = true;
  statusText.textContent = 'solving';
  statSolve.textContent = solveEl.value;
  let path = null;
  if(solveEl.value === 'bfs') path = solverBFS();
  else path = solverDFS();

  if(!path){
    statusText.textContent = 'no path';
    statPaths.textContent = '0';
    busy = false;
    return;
  }
  await reveal(path);
  statusText.textContent = 'solved';
  busy = false;
}

/* reset & save */
function doReset(){
  if(busy) return;
  initEmpty(0,0); // clears
  clearCanvas();
  gridText.textContent = '- × -';
  statusText.textContent = 'reset';
  statGen.textContent = '—';
  statSolve.textContent = '—';
  statSteps.textContent = '0';
  statLength.textContent = '0';
  statPaths.textContent = '0';
  grid = [];
}

function doSave(){
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = 'pathfinding_visual.png';
  a.click();
}

/* small helpers */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }

/* events */
buildBtn.addEventListener('click', ()=>doBuild().catch(e=>{ console.error(e); statusText.textContent='error'; busy=false; }));
solveBtn.addEventListener('click', ()=>doSolve().catch(e=>{ console.error(e); statusText.textContent='error'; busy=false; }));
resetBtn.addEventListener('click', doReset);
saveBtn.addEventListener('click', doSave);

/* initial state */
initEmpty(COLS, ROWS);
render();
statusText.textContent = 'ready';

</script>
</body>
</html>
